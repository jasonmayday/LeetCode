# **拓扑排序**

拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：
    
    1. 每个顶点出现且只出现一次。
    2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

**总结：**

    1. 如果这个图不是 DAG，那么它是没有拓扑序的；
    2. 如果是 DAG，那么它至少有一个拓扑序；
    3. 反之，如果它存在一个拓扑序，那么这个图必定是 DGA.

<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/8468731-9638ca653dd3aca9.png?imageMogr2/auto-orient/strip|imageView2/2/w/335/format/webp" alt="Editor" width="300"> </div>

**AOV (Activity On Vertex) 网络，在这种图里：**

    顶点：表示活动；
    边：表示活动间的先后关系

入度：顶点的入度是指「指向该顶点的边」的数量；

出度：顶点的出度是指该顶点指向其他点的边的数量。

**拓扑排序一般流程：**

    1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。
    2. 从图中删除该顶点和所有以它为起点的有向边。
    3. 重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/8468731-da38fa971e5d52b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp" alt="Editor" width="500"> </div>

于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。

通常，一个有向无环图可以有一个或多个拓扑排序序列。

## **拓扑排序算法**
### **卡恩算法**
假设L是存放结果的列表，先找到那些入度为零的节点，把这些节点放到L中，因为这些节点没有任何的父节点。然后把与这些节点相连的边从图中去掉，再寻找图中的入度为零的节点。对于新找到的这些入度为零的节点来说，他们的父节点已经都在L中了，所以也可以放入L。重复上述操作，直到找不到入度为零的节点。如果此时L中的元素个数和节点总数相同，说明排序完成；如果L中的元素个数和节点总数不同，说明原图中存在环，无法进行拓扑排序。

``` python
L ← 包含已排序的元素的列表，目前为空
S ← 入度为零的节点的集合
当 S 非空时：
    将节点n从S移走
    将n加到L尾部
    选出任意起点为n的边e = (n,m)，移除e。如m没有其它入边，则将m加入S。
    重复上一步。
如图中有剩余的边则：
    return error   (图中至少有一个环)
否则： 
    return L   (L为图的拓扑排序)
```

### **深度优先搜索**
另一种拓扑排序的方法运用了深度优先搜索。深度优先搜索以任意顺序循环遍历图中的每个节点。若搜索进行中碰到之前已经遇到的节点，或碰到叶节点，则中止算法。

``` python
L ← 包含已排序的元素的列表，目前为空
当图中存在未永久标记的节点时：
    选出任何未永久标记的节点n
    visit(n)
```
``` python
function visit(节点 n)
    如n已有永久标记：
        return
    如n已有临时标记：
        stop   (不是定向无环图)
    将 n 临时标记
    选出以 n 为起点的边(n,m)，visit(m)
    重复上一步
    去掉n的临时标记
    将n永久标记
    将n加到L的起始
```