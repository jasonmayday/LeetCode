"""
给定一个正整数 n ，返回范围在 [0, n] 都非负整数中，其二进制表示不包含 连续的 1 的个数。

示例 1:
    输入: n = 5
    输出: 5
    解释: 
        下面是带有相应二进制表示的非负整数<= 5：
        0 : 0
        1 : 1
        2 : 10
        3 : 11
        4 : 100
        5 : 101
        其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。

示例 2:
    输入: n = 1
    输出: 2

示例 3:
    输入: n = 2
    输出: 3

提示:
    1 <= n <= 10^9

"""

""" 字典树 + 动态规划 """
class Solution:
    def findIntegers(self, n: int) -> int:
        # 预处理第 i 层满二叉树的路径数量
        dp = [0] * 31
        dp[0] = 1   # dp[n] 定义为从低位往高位数，前 n 个二进制位，所能产生的合法数字的个数。
        dp[1] = 1   # 例如dp[2] = 3。三个合法数字分别为00，01，10。11由于有连续的1，不合法。
        for i in range(2, 31):
            dp[i] = dp[i - 1] + dp[i - 2]

        # pre 记录上一层的根节点值，res 记录最终路径数
        pre = 0
        res = 0

        for i in range(29, -1, -1):
            val = (1 << i)
            # if 语句判断 当前子树是否有右子树
            if n & val:
                # 有右子树
                n -= val
                res += dp[i + 1] # 先将左子树（满二叉树）的路径加到结果中
                if pre == 1:
                    # 上一层为 1，之后要处理的右子树根节点肯定也为 1
                    # 此时连续两个 1，不满足题意，直接退出
                    break
                pre = 1
            else:
                # 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
                pre = 0

            if i == 0:
                res += 1

        return res

if __name__ == "__main__":
    n = 5
    sol = Solution()
    result = sol.findIntegers(n)
    print(result)