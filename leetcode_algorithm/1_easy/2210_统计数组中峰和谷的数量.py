"""
https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/

给你一个下标从 0 开始的整数数组 nums 。
如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。
类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。
对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。

注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。

返回 nums 中峰和谷的数量。

示例 1：
    输入：nums = [2,4,1,1,6,5]
    输出：3
    解释：
        在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
        在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 > 2 且 4 > 1 ，下标 1 是一个峰。
        在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 2 是一个谷。
        在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。
        在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 > 1 且 6 > 5 ，下标 4 是一个峰。
        在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
        共有 3 个峰和谷，所以返回 3 。

示例 2：
    输入：nums = [6,6,5,5,4,1]
    输出：0
    解释：
        在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
        在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。
        在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 2 既不是峰也不是谷。
        在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 3 既不是峰也不是谷。
        在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 < 5 且 4 > 1 ，下标 4 既不是峰也不是谷。
        在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
        共有 0 个峰和谷，所以返回 0 。

提示：
    3 <= nums.length <= 100
    1 <= nums[i] <= 100

"""

from typing import List

""" 方法一：逐个判断"""
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        res = 0   # 峰与谷的数量
        n = len(nums)
        for i in range(1, n - 1):
            if nums[i] == nums[i-1]:    # 为了防止重复遍历，我们只判断每个可能的峰或谷的第一个下标
                continue                # 即当 nums[i]=nums[i−1] 时，我们跳过该下标
            
            left = 0   # 左边可能的不相等邻居对应状态, 0 代表未找到或不存在下标 i 左边的不相等邻居
            for j in range(i - 1, -1, -1):  # 从 下标 i 左边一位向左寻找，直至找到第一个不等于 nums[i] 的元素
                if nums[j] > nums[i]:
                    left = 1            #  1 代表左边邻居大于该元素
                    break
                elif nums[j] < nums[i]:
                    left = -1           # −1 代表左边邻居小于该元素
                    break
            
            right = 0   # 右边可能的不相等邻居对应状态, 0 代表未找到或不存在下标 i 右边的不相等邻居
            for j in range(i + 1, n):       # 从 下标 i 右边一位向右寻找，直至找到第一个不等于 nums[i] 的元素
                if nums[j] > nums[i]:
                    right = 1           #  1 代表右边邻居大于该元素
                    break
                elif nums[j] < nums[i]:
                    right = -1          # −1 代表右边邻居小于该元素
                    break
            
            if left == right and left != 0: # i 下标数字的左右边邻居与 nums[i]的不相等状态一样，此时下标 i 为峰或谷的一部分
                res += 1
        return res

if __name__ == "__main__":
    nums = [2,4,1,1,6,5]
    sol = Solution()
    result = sol.countHillValley(nums)
    print (result)